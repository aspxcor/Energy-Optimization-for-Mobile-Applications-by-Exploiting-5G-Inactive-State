import os

import sklearn
from deepforest import CascadeForestClassifier
from sklearn import preprocessing
from sklearn.ensemble import RandomForestClassifier
import joblib
import pandas as pd
import numpy as np

app = ''
# app = ''

# in mJ
energy_idle_2_con = 400.5*1.2
energy_inac_2_con = 161.5*0.2
energy_con_2_idle = 10
energy_con_2_ina = 10
energy_inac_2_idle = 10

# in mW
energy_con = 1026.4
energy_idle = 112.5
energy_inac = 182.5

# delay
delay_idle_2_con = 1.2
delay_inac_2_con = 0.2

t_w = 0.3
t_s = 2
t_ss = 1.5*t_s # the timer

# 分析不同t_s设置的影响
# t_ss = 3
# t_s = 0.6*t_ss

training_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/final_features_all_feature_"+str(t_w)+".csv"
df_features = pd.read_csv(training_path)
data_feature = df_features.loc[:,:].values
col = np.shape(data_feature)[1]
data_features = data_feature[:,1:col-1]
le = preprocessing.LabelEncoder()
length = len(data_features[:,-33])
trace_1 = []
for i in range(length):
    trace_1.append(data_features[i,-33])
print(trace_1)
data_features[:,-3] = le.fit_transform(data_features[:,-3])
data_features[:,-13] = le.fit_transform(data_features[:,-13])
data_features[:,-33] = le.fit_transform(data_features[:,-33])
le.fit(trace_1)
ss = sklearn.preprocessing.MinMaxScaler()
ss.fit(data_features)

prediction_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/final_features_all_feature_for_prediction_"+str(t_w)+".csv"
df_features_pre = pd.read_csv(prediction_path)
data_feature_pre = df_features_pre.loc[:,:].values
col = np.shape(data_feature_pre)[1]
data_features_pre = data_feature_pre[:,1:col-1]
le_pre = preprocessing.LabelEncoder()
data_features_pre[:,-4] = le_pre.fit_transform(data_features_pre[:,-4])
data_features_pre[:,-14] = le_pre.fit_transform(data_features_pre[:,-14])
data_features_pre[:,-34] = le_pre.fit_transform(data_features_pre[:,-34])
ss_pre = sklearn.preprocessing.MinMaxScaler()
ss_pre.fit(data_features_pre)
features_final_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/"
rf_model = joblib.load(features_final_path+'rf_' + str(t_w) + '.model')
df_model = CascadeForestClassifier()
df_model.load(features_final_path+'df_' + str(t_w) + '.model')

all_command = open(features_final_path+'all_unique_command.txt','r')
all_command = all_command.read()[2:-2].split('\', \'')
# print(all_command)
# print(np.shape(all_command))
# input()
total_energys = []
total_delays = []

def isInt(num):
    try:
        num = int(str(num))
        return isinstance(num, int)
    except:
        return False
feature_dirs = []
trace_nums = []
for file in os.listdir(features_final_path):
    # print(file)
    file_path = os.path.join(features_final_path,file)
    if os.path.isdir(file_path) and ("trace" in file):
        feature_dirs.append(file_path)
        temp_pos = file.rindex('e')
        trace_nums.append(file[temp_pos+1:])
for trace_num in trace_nums:
    print(trace_num)
    store_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/trace" + str(trace_num) + "/"

    file_path_related_pkt = store_path + 'pcap_' + str(trace_num) + '_all_feature_final.csv'
    file_path_strace = store_path + 'trace_' + str(trace_num) + '.csv'
    file_path_pcap = store_path + 'pcap_' + str(trace_num) + '_all_feature.csv'
    file_path_battery = store_path+'battery_'+str(trace_num)+'.csv'
    file_path_cpu = store_path + 'cpu_' + str(trace_num) + '.csv'
    file_path_memory = store_path + 'memory_' + str(trace_num) + '.csv'
    file_path_logcat = store_path + 'logcat_' + str(trace_num) + '.csv'

    df_strace = pd.read_csv(file_path_strace)
    df_pcap = pd.read_csv(file_path_pcap)
    df_battery = pd.read_csv(file_path_battery)
    df_cpu = pd.read_csv(file_path_cpu)
    df_logcat = pd.read_csv(file_path_logcat)
    df_memory = pd.read_csv(file_path_memory)

    # useful data are start from index 1
    data_strace = df_strace.loc[:, :].values
    data_pcap = df_pcap.loc[:, :].values
    data_battery = df_battery.loc[:, :].values
    data_cpu = df_cpu.loc[:, :].values
    data_logcat = df_logcat.loc[:, :].values
    data_memory = df_memory.loc[:, :].values

    df_related_pkt = pd.read_csv(file_path_related_pkt)
    data_related_pkt = df_related_pkt.loc[:, :].values
    pkt_len = len(data_related_pkt)
    pre_stat = 0
    actual_stat = 0
    i=0

    strace_length = len(data_strace)
    pkt_length = len(data_pcap)
    battery_length = len(data_battery)
    cpu_length = len(data_cpu)
    logcat_length = len(data_logcat)
    memory_length = len(data_memory)

    trace_cur_index = 0
    battery_index = 0
    cpu_index = 0
    logcat_index = 0
    memory_index = 0

    cont_flag = 0
    active_start_time = 0
    total_energy = 0
    total_delay = 0

    # active_time_start = []
    # active_time_end = []
    # eoc_time_start = []

    # judge_pkt = []
    # judge_active = []
    # judge_eocrf = []
    # judge_eocidle = []
    # print(data_related_pkt[0][:])
    # input()

    while i < pkt_len-1:
        # if pre_stat == 0:
        #     active_time_start.append(data_related_pkt[i][2])
        #     if i != 0:
        #         active_time_end.append(data_related_pkt[i-1][2])
        #         eoc_time_start.append(data_related_pkt[i-1][2])
        if cont_flag == 0:
            active_start_time = data_related_pkt[i][2]
        # active
        if data_related_pkt[i+1][2]-data_related_pkt[i][2]<=t_w:
            i+=1
            cont_flag = 1
            if i == pkt_len - 1:
                active_end_time = data_related_pkt[i][2]
                total_energy += ((active_end_time - active_start_time) * energy_con)
            continue
        # print(i)
        cont_flag = 0
        # judge_pkt.append(i)
        start_time = data_related_pkt[i][2]
        end_time = data_related_pkt[i][2]+t_w
        temp_feature = [0] * np.shape(all_command)[0]

        while data_strace[trace_cur_index][1] < start_time:
            trace_cur_index += 1
            if trace_cur_index >= strace_length:
                trace_cur_index -= 1
                break
        # while data_pcap[index_pcap][1] < start_time:
        #     index_pcap += 1
        while data_battery[battery_index][1] < start_time:
            battery_index += 1
        while data_cpu[cpu_index][1] < start_time:
            cpu_index += 1
        while data_logcat[logcat_index][1] < start_time:
            logcat_index += 1
            if logcat_index >= logcat_length:
                logcat_index = logcat_index - 1
                break
        while data_memory[memory_index][1] < start_time:
            memory_index += 1
            if memory_index >= memory_length:
                memory_index = memory_index - 1
                break

        # collect features in the current data item
        while data_strace[trace_cur_index][1] <= end_time:
            command_index = all_command.index(data_strace[trace_cur_index][2])
            temp_feature[command_index] = 1
            trace_cur_index += 1
            if trace_cur_index >= strace_length:
                trace_cur_index -= 1
                break
        # print(data_strace[trace_cur_index - 1][4])
        if '0x' in str(data_strace[trace_cur_index - 1][4]):
            data_strace[trace_cur_index - 1][4] = int(data_strace[trace_cur_index - 1][4], 16)
        # return_value = np.reshape(int(data_strace[trace_cur_index - 1][4]),[1])
        return_value = []
        if isInt(str(data_strace[trace_cur_index - 1][4])):
            return_value.append(int(data_strace[trace_cur_index - 1][4]))
        else:
            return_value.append(0)
            print(str(data_strace[trace_cur_index - 1][4]))
            print("not number")
        # print(np.reshape([1,2],[-1]))
        # print("ret:", return_value)
        # return_value = le.transform(return_value)
        if return_value[0] not in trace_1:
            print("not in")
            return_value[0] = 0
        temp_feature.append(le.transform(return_value)[0])  # ret
        temp_feature.append(data_strace[trace_cur_index - 1][5])  # duration
        temp_feature.append(data_related_pkt[i][9])  # pkt len
        temp_feature.append(data_related_pkt[i][10])  # ttl

        while data_battery[battery_index][1] <= end_time:
            battery_index += 1
            if battery_index >= battery_length:
                battery_index = battery_index - 1
                break
        temp_battery_battery = data_battery[battery_index - 1][2] - data_battery[battery_index - 2][2]
        temp_battery_cpu = data_battery[battery_index - 1][3] - data_battery[battery_index - 2][3]
        temp_battery_radio = data_battery[battery_index - 1][4] - data_battery[battery_index - 2][4]
        temp_battery_sensor = data_battery[battery_index - 1][5] - data_battery[battery_index - 2][5]
        temp_battery_wake = data_battery[battery_index - 1][6] - data_battery[battery_index - 2][6]
        temp_battery_include = data_battery[battery_index - 1][7] - data_battery[battery_index - 2][7]
        temp_battery_proportional = data_battery[battery_index - 1][8] - data_battery[battery_index - 2][8]
        temp_battery_screen = data_battery[battery_index - 1][9] - data_battery[battery_index - 2][9]
        temp_battery_ms_per_pkt = data_battery[battery_index - 1][10]
        temp_battery_num_pkt = data_battery[battery_index - 1][11] - data_battery[battery_index - 2][11]
        temp_battery_t_trans = data_battery[battery_index - 1][12] - data_battery[battery_index - 2][12]
        temp_feature.append(temp_battery_battery)
        temp_feature.append(temp_battery_cpu)
        temp_feature.append(temp_battery_radio)
        temp_feature.append(temp_battery_sensor)
        temp_feature.append(temp_battery_wake)
        temp_feature.append(temp_battery_include)
        temp_feature.append(temp_battery_proportional)
        temp_feature.append(temp_battery_screen)
        temp_feature.append(temp_battery_ms_per_pkt)
        temp_feature.append(temp_battery_num_pkt)
        temp_feature.append(temp_battery_t_trans)
        # cpu feature
        while data_cpu[cpu_index][1] <= end_time:
            cpu_index += 1
            if cpu_index >= cpu_length:
                cpu_index = cpu_index - 1
                break
        temp_cpu_prio = data_cpu[cpu_index - 1][2]
        temp_cpu_nice = data_cpu[cpu_index - 1][3]
        temp_cpu_virt = data_cpu[cpu_index - 1][4]
        temp_cpu_res = data_cpu[cpu_index - 1][5]
        temp_cpu_shr = data_cpu[cpu_index - 1][6]
        temp_cpu_state = data_cpu[cpu_index - 1][7]
        if temp_cpu_state == 'R':
            temp_cpu_state = 0
        elif temp_cpu_state == 'S':
            temp_cpu_state = 1
        elif temp_cpu_state == 't':
            temp_cpu_state = 2
        elif temp_cpu_state == 'D':
            temp_cpu_state = 1
        else:
            # print(temp_cpu_state)
            exit(2)
        temp_cpu_cpu = data_cpu[cpu_index - 1][8]
        temp_cpu_mem = data_cpu[cpu_index - 1][9]
        temp_feature.append(temp_cpu_prio)
        temp_feature.append(temp_cpu_nice)
        temp_feature.append(temp_cpu_virt)
        temp_feature.append(temp_cpu_res)
        temp_feature.append(temp_cpu_shr)
        temp_feature.append(temp_cpu_state)
        temp_feature.append(temp_cpu_cpu)
        temp_feature.append(temp_cpu_mem)
        # memory feature
        while data_memory[memory_index][1] <= end_time:
            memory_index += 1
            if memory_index >= memory_length:
                memory_index = memory_index - 1
                break
        temp_mem_pss_total = data_memory[memory_index - 1][2]
        temp_mem_pri_dirty = data_memory[memory_index - 1][3]
        temp_mem_pri_clean = data_memory[memory_index - 1][4]
        temp_mem_swap_dirty = data_memory[memory_index - 1][5]
        temp_mem_heap_size = data_memory[memory_index - 1][6]
        temp_mem_heap_alloc = data_memory[memory_index - 1][7]
        temp_mem_heap_free = data_memory[memory_index - 1][8]
        temp_feature.append(temp_mem_pss_total)
        temp_feature.append(temp_mem_pri_dirty)
        temp_feature.append(temp_mem_pri_clean)
        temp_feature.append(temp_mem_swap_dirty)
        temp_feature.append(temp_mem_heap_size)
        temp_feature.append(temp_mem_heap_alloc)
        temp_feature.append(temp_mem_heap_free)
        # logcat feature
        num_of_logs = 0
        while data_logcat[logcat_index][1] <= end_time:
            num_of_logs += 1
            logcat_index += 1
            if logcat_index >= logcat_length:
                logcat_index = logcat_index - 1
                break
        temp_log_level = data_logcat[logcat_index - 1][4]
        if temp_log_level == 'D':
            temp_log_level = 0
        elif temp_log_level == 'E':
            temp_log_level = 1
        elif temp_log_level == 'I':
            temp_log_level = 2
        elif temp_log_level == 'V':
            temp_log_level = 3
        elif temp_log_level == 'W':
            temp_log_level = 4
        elif temp_log_level == 'F':
            temp_log_level = 1
        else:
            exit(1)
        temp_log_num = num_of_logs
        temp_feature.append(temp_log_level)
        temp_feature.append(temp_log_num)

        temp_feature.append(actual_stat)

        # print(temp_feature)
        # print(np.shape(temp_feature))

        temp_feature_for_cla = np.reshape(temp_feature,[1,-1])
        temp_feature_for_cla = ss.transform(temp_feature_for_cla)
        y_cla = rf_model.predict(temp_feature_for_cla)
        # print(y_pred)

        # calculate power to i+1
        # active state
        if y_cla == 1:
            pre_stat = 1
            if data_related_pkt[i+1][2]-data_related_pkt[i][2]<t_s:
                actual_stat = 1
                cont_flag = 1
                i += 1
                if i == pkt_len - 1:
                    active_end_time = data_related_pkt[i][2]
                    total_energy += ((active_end_time - active_start_time) * energy_con)
                continue
            elif t_s <= data_related_pkt[i + 1][2]-data_related_pkt[i][2] < t_ss:
                actual_stat = 0
                active_end_time = data_related_pkt[i][2]+t_s
                inactive_time = data_related_pkt[i+1][2]-data_related_pkt[i][2]-t_s
                total_energy += ((active_end_time-active_start_time)*energy_con+inactive_time*energy_inac+energy_inac_2_con)
                total_delay += delay_inac_2_con
            elif data_related_pkt[i+1][2]-data_related_pkt[i][2]>=t_ss:
                actual_stat = 0
                active_end_time = data_related_pkt[i][2] + t_s
                inactive_time = t_ss-t_s
                idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_ss
                total_energy += ((active_end_time - active_start_time) * energy_con +inactive_time*energy_inac + idle_time * energy_idle + energy_idle_2_con)
                total_delay += delay_idle_2_con
            else:
                exit(3)

            # judge_active.append(i)
            # print('no')
        # eoc state
        elif y_cla == 0:
            pre_stat = 0
            # print('yes')
            temp_feature.append(y_cla)
            temp_feature_for_pre = np.reshape(temp_feature,[1,-1])
            temp_feature_for_pre = ss_pre.transform(temp_feature_for_pre)
            y_pre = df_model.predict(temp_feature_for_pre)
            # idle state
            if y_pre == 1:
                # judge_eocidle.append(i)
                # print('idle')
                if data_related_pkt[i + 1][2] - data_related_pkt[i][2] < t_s:
                    actual_stat = 1
                    active_end_time = data_related_pkt[i][2] + t_w
                    idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_w
                    total_energy += ((active_end_time - active_start_time) * energy_con + idle_time * energy_idle + energy_idle_2_con)
                elif t_s <= data_related_pkt[i + 1][2] - data_related_pkt[i][2] < t_ss:
                    actual_stat = 0
                    active_end_time = data_related_pkt[i][2] + t_w
                    idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_w
                    total_energy += ((active_end_time - active_start_time) * energy_con + idle_time * energy_idle + energy_idle_2_con)
                elif data_related_pkt[i + 1][2] - data_related_pkt[i][2] >= t_ss:
                    actual_stat = 0
                    active_end_time = data_related_pkt[i][2] + t_w
                    idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_w
                    total_energy += ((active_end_time - active_start_time) * energy_con + idle_time * energy_idle + energy_idle_2_con)
                else:
                    exit(4)
                total_delay += delay_idle_2_con
            # fr state
            elif y_pre == 0:
                # judge_eocrf.append(i)
                # print('fr')
                if data_related_pkt[i + 1][2] - data_related_pkt[i][2] < t_s:
                    actual_stat = 1
                    active_end_time = data_related_pkt[i][2] + t_w
                    inactive_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_w
                    total_energy += ((active_end_time - active_start_time) * energy_con + inactive_time * energy_inac + energy_inac_2_con)
                    total_delay += delay_inac_2_con
                elif t_s <= data_related_pkt[i + 1][2] - data_related_pkt[i][2] < t_ss:
                    actual_stat = 0
                    active_end_time = data_related_pkt[i][2] + t_w
                    inactive_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_w
                    total_energy += ((active_end_time - active_start_time) * energy_con + inactive_time * energy_inac + energy_inac_2_con)
                    total_delay += delay_inac_2_con
                elif data_related_pkt[i + 1][2] - data_related_pkt[i][2] >= t_ss:
                    actual_stat = 0
                    active_end_time = data_related_pkt[i][2] + t_w
                    inactive_time = t_ss-t_w
                    idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2] - t_ss
                    total_energy += ((active_end_time - active_start_time) * energy_con + inactive_time * energy_inac + idle_time*energy_idle + energy_idle_2_con )
                    total_delay += delay_idle_2_con
                else:
                    exit(5)
        else:
            exit(1)
        # print(pre_stat)
        i += 1
        # input()

    print("total_energy_my: ",total_energy)
    total_energys.append(total_energy)
    print("total_delay_my: ", total_delay)
    total_delays.append(total_delay)
    # input()

if app == '':
    app = '/browser'
print("energies_"+app[1:]+"_ours_"+str(int(t_s*10))+" = ", total_energys)
print(np.shape(total_energys))
print("delays_"+app[1:]+"_ours_"+str(int(t_s*10))+" = ", total_delays)
print(np.shape(total_delays))




