import os

import sklearn
from deepforest import CascadeForestClassifier
from sklearn import preprocessing
from sklearn.ensemble import RandomForestClassifier
import joblib
import pandas as pd
import numpy as np

app = '/qqmusic'
# app = ''

# # in mJ
# energy_idle_2_con = 1037.8*1
# energy_inac_2_con = 798.8*0.4
# energy_con_2_idle = 10
# energy_con_2_ina = 10
# energy_inac_2_idle = 10
#
# # in mW
# energy_con = 1875
# energy_idle = 750
# energy_inac = 820

# in mJ
energy_idle_2_con = 400.5*1.2
energy_inac_2_con = 161.5*0.2
energy_con_2_idle = 10
energy_con_2_ina = 10
energy_inac_2_idle = 10

# in mW
energy_con = 1026.4
energy_idle = 112.5
energy_inac = 182.5

# delay
delay_idle_2_con = 1.2
delay_inac_2_con = 0.2

t_w = 0.3
t_s = 2
t_ss = 1.5*t_s
total_energys = []
total_delays = []

features_final_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/"
feature_dirs = []
trace_nums = []
for file in os.listdir(features_final_path):
    # print(file)
    file_path = os.path.join(features_final_path,file)
    if os.path.isdir(file_path) and ("trace" in file):
        feature_dirs.append(file_path)
        temp_pos = file.rindex('e')
        trace_nums.append(file[temp_pos+1:])
for trace_num in trace_nums:
# trace_num = 1
    store_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/trace" + str(trace_num) + "/"
    file_path_related_pkt = store_path + 'pcap_' + str(trace_num) + '_all_feature_final.csv'
    df_related_pkt = pd.read_csv(file_path_related_pkt)
    data_related_pkt = df_related_pkt.loc[:, :].values
    pkt_len = len(data_related_pkt)
    actual_stat = 0
    i=0
    cont_flag = 0
    active_start_time = 0
    total_energy = 0
    total_delay = 0

    while i < pkt_len-1:
        # if pre_stat == 0:
        #     active_time_start.append(data_related_pkt[i][2])
        #     if i != 0:
        #         active_time_end.append(data_related_pkt[i-1][2])
        #         eoc_time_start.append(data_related_pkt[i-1][2])
        if cont_flag == 0:
            active_start_time = data_related_pkt[i][2]
        # active
        if data_related_pkt[i+1][2]-data_related_pkt[i][2]<=t_w:
            i+=1
            cont_flag = 1
            if i == pkt_len - 1:
                active_end_time = data_related_pkt[i][2]
                total_energy += ((active_end_time - active_start_time) * energy_con)
            continue
        print(i)
        cont_flag = 0
        if data_related_pkt[i + 1][2] - data_related_pkt[i][2] < t_s:
            actual_stat = 1
            cont_flag = 1
            i += 1
            if i == pkt_len - 1:
                active_end_time = data_related_pkt[i][2]
                total_energy += ((active_end_time - active_start_time) * energy_con)
            continue
        elif t_s <= data_related_pkt[i + 1][2]-data_related_pkt[i][2] < t_ss:
            actual_stat = 0
            active_end_time = data_related_pkt[i][2]
            inactive_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2]
            total_energy += ((active_end_time - active_start_time) * energy_con + inactive_time * energy_inac + energy_inac_2_con)
            total_delay += delay_inac_2_con
        elif data_related_pkt[i+1][2]-data_related_pkt[i][2]>=t_ss:
            actual_stat = 0
            active_end_time = data_related_pkt[i][2]
            idle_time = data_related_pkt[i + 1][2] - data_related_pkt[i][2]
            total_energy += ((active_end_time - active_start_time) * energy_con + idle_time * energy_idle + energy_idle_2_con)
            total_delay += delay_idle_2_con
        else:
            exit(2)
        i += 1

    print("total_energy_optimal: ",total_energy)
    total_energys.append(total_energy)
    print("total_delay_optimal: ", total_delay)
    total_delays.append(total_delay)
    # input()

if app == '':
    app = '/browser'
print("energies_"+app[1:]+"_optimal_"+str(int(t_w*10))+" = ", total_energys)
print(np.shape(total_energys))
print("delays_"+app[1:]+"_optimal_"+str(int(t_w*10))+" = ", total_delays)
print(np.shape(total_delays))