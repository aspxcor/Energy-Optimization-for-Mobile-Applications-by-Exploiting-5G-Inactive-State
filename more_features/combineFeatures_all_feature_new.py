from scapy.all import *
import json
import numpy as np
import datetime
import pandas as pd
import math
from collections import Counter
import os

# app = '/weibo'
# port_num = '5352'

t_w = 0.3
t_s = 2

app = '/qqmusic'
port_num = ''

features_final_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/"
feature_dirs = []
trace_nums = []
all_unique_command = []
for file in os.listdir(features_final_path):
    print(file)
    file_path = os.path.join(features_final_path,file)
    if os.path.isdir(file_path) and ("trace" in file):
        feature_dirs.append(file_path)
        temp_pos = file.rindex('e')
        trace_nums.append(file[temp_pos+1:])
print(trace_nums)

inter_pkt_time = []

for trace_num in trace_nums:
    # trace_num = '100'
    store_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/trace" + str(trace_num) + "/"
    path = store_path + 'pcap_' + trace_num + '_all_feature_final.csv'

    print('trace_num:', trace_num)
    file_path_strace = store_path+'trace_'+trace_num+'.csv'
    file_path_pcap = store_path + 'pcap_'+trace_num+'_all_feature.csv'
    file_path_pidport = store_path + 'port_PID'+ port_num +'_'+trace_num+'.csv'

    df_strace = pd.read_csv(file_path_strace)
    df_pcap = pd.read_csv(file_path_pcap)
    df_pidport = pd.read_csv(file_path_pidport)

    # print("输出strace列标题",df_strace.columns.values)
    # print("输出pcap列标题",df_pcap.columns.values)
    # print("输出pid_port列标题",df_pidport.columns.values)

    data_strace = df_strace.loc[:,:].values
    data_pcap = df_pcap.loc[:,:].values
    data_pidport = df_pidport.loc[:,:].values
    # print(data_pidport)
    # print(np.shape(data_pidport))
    # data_pidport = df_pidport.values.tolist()
    # print(data_pidport)
    # print(np.shape(data_pidport))
    # input()

    pid_related_pkt = []
    pkt_length = len(data_pcap)
    port_length = len(data_pidport)
    cur_search_index = 0
    # for index in range(pkt_length):
    #     pkt_time[index] = 3600*data_pcap[index][1]+60*data_pcap[index][2]+data_pcap[index][3]+data_pcap[index][4]/1000000.0
    # for index_port in range(port_length):
    #     port_time[index_port] = 3600*data_pidport[index_port][1]+60*data_pidport[index_port][2]+data_pidport[index_port][3]+data_pidport[index_port][4]/1000000000.0

    each_port_len = len(data_pidport[0])
    for index in range(pkt_length):
        while data_pidport[cur_search_index][1] < data_pcap[index][1]:
            cur_search_index = cur_search_index + 1
            if cur_search_index >= port_length:
                cur_search_index = cur_search_index - 1
                break
        # print(cur_search_index)
        # print(index)
        # input()
        cur_search_index = cur_search_index - 1
        start_port = 6
        temp_port = []
        for i in range(start_port,each_port_len):
            if np.isnan(data_pidport[cur_search_index][i]):
                break
            else:
                temp_port.append(data_pidport[cur_search_index][i])
        for i in range(start_port,each_port_len):
            if np.isnan(data_pidport[cur_search_index+1][i]):
                break
            else:
                temp_port.append(data_pidport[cur_search_index+1][i])
            # print(index)
            # print(temp_port)
        # print(cur_search_index)
        # print(index)
        # print(temp_port)
        # input()
        if (data_pcap[index][6] in temp_port) or (data_pcap[index][7] in temp_port):
            pid_related_pkt.append(data_pcap[index])

    # print(pid_related_pkt)
    # print(np.shape(pid_related_pkt))
    # input()
    pid_related_pkt.sort(key=lambda x: x[1], reverse=False)
    for index_pkt in range(1,len(pid_related_pkt)):
        inter_pkt_time.append(pid_related_pkt[index_pkt][1]-pid_related_pkt[index_pkt-1][1])
    # print("inter_pkt_time:",inter_pkt_time)
    dataframe = pd.DataFrame(pid_related_pkt)
    # print(dataframe)

    # if not os.path.exists(path):
    #     dataframe.to_csv(store_path + 'pcap_'+trace_num+'_all_feature_final.csv')
    dataframe.to_csv(store_path + 'pcap_'+trace_num+'_all_feature_final.csv')

    strace_length = len(data_strace)
    unique_command = []
    for i in range(strace_length):
        if data_strace[i][2] not in unique_command:
            unique_command.append(data_strace[i][2])
        if data_strace[i][2] not in all_unique_command:
            all_unique_command.append(data_strace[i][2])
    print(unique_command)
    print("unique command:", np.shape(unique_command))
    # break

unique_command_length = np.shape(all_unique_command)[0]
print(all_unique_command)
print("unique_command_length:",unique_command_length)
file_command = open(features_final_path+'all_unique_command.txt','w')
file_command.write(str(all_unique_command))

file_command = open(features_final_path+'inter_pkt_times.txt','w')
file_command.write(str(inter_pkt_time))
# input()

all_data_item = []
eos_data_item = []
intra_session_time = []
inter_session_time = []
inter_item_time = []

for trace_num in trace_nums:
    # trace_num = '100'
    store_path = "E:/Emnets/5G/powerMonitor/ZTE/data"+app+"/trace" + str(trace_num) + "/"
    file_path_strace = store_path + 'trace_' + trace_num + '.csv'
    file_path_pcap = store_path + 'pcap_' + trace_num + '_all_feature.csv'
    file_path_pidport = store_path + 'port_PID' + port_num + '_' + trace_num + '.csv'
    file_path_related_pkt = store_path+'pcap_'+trace_num+'_all_feature_final.csv'
    file_path_battery = store_path+'battery_'+trace_num+'.csv'
    file_path_cpu = store_path + 'cpu_' + trace_num + '.csv'
    file_path_logcat = store_path + 'logcat_' + trace_num + '.csv'
    file_path_memory = store_path + 'memory_' + trace_num + '.csv'

    df_strace = pd.read_csv(file_path_strace)
    df_pcap = pd.read_csv(file_path_pcap)
    df_pidport = pd.read_csv(file_path_pidport)
    df_related_pkt = pd.read_csv(file_path_related_pkt)
    df_battery = pd.read_csv(file_path_battery)
    df_cpu = pd.read_csv(file_path_cpu)
    df_logcat = pd.read_csv(file_path_logcat)
    df_memory = pd.read_csv(file_path_memory)

    # print("输出strace列标题", df_strace.columns.values)
    # print("输出pcap列标题", df_pcap.columns.values)
    # print("输出pid_port列标题", df_pidport.columns.values)
    # print("输出related_pkt列标题", df_related_pkt.columns.values)

    data_strace = df_strace.values.tolist()
    data_pcap = df_pcap.values.tolist()
    data_pidport = df_pidport.values.tolist()
    data_related_pkt = df_related_pkt.loc[:,:].values
    data_battery = df_battery.values.tolist()
    data_cpu = df_cpu.values.tolist()
    data_logcat = df_logcat.values.tolist()
    data_memory = df_memory.values.tolist()
    # print(np.shape(data_battery))
    # print(data_battery)
    # input()

    strace_length = len(data_strace)
    pkt_length = len(data_pcap)
    port_length = len(data_pidport)
    battery_length = len(data_battery)
    cpu_length = len(data_cpu)
    logcat_length = len(data_logcat)
    memory_length = len(data_memory)

    temp_len = np.shape(data_related_pkt)[0]
    col = np.shape(data_related_pkt)[1]
    pid_related_pkt = []
    for temp_i in range(temp_len):
        pid_related_pkt.append(data_related_pkt[temp_i, 1:col])

    # pid_related_pkt = data_related_pkt[:, 1:col]
    # print(pid_related_pkt)
    # print(np.shape(pid_related_pkt))
    # input()
    data_strace.sort(key=lambda x: x[1], reverse=False)
    # data_strace.sort(key=lambda x: x[1], reverse=False)
    data_pcap.sort(key=lambda x: x[1], reverse=False)
    data_battery.sort(key=lambda x: x[1], reverse=False)
    data_cpu.sort(key=lambda x: x[1], reverse=False)
    data_logcat.sort(key=lambda x: x[1], reverse=False)
    data_memory.sort(key=lambda x: x[1], reverse=False)
    pid_related_pkt.sort(key=lambda x: x[1], reverse=False)
    # print(pid_related_pkt)


    final_pkt_length = len(pid_related_pkt)
    # print("final_pkt_length:",final_pkt_length)
    data_item = []
    trace_cur_index = 0
    battery_index = 2
    cpu_index = 2
    logcat_index = 2
    memory_index = 2
    # print("data:",data_strace[trace_cur_index][1])
    # print("pid:",pid_related_pkt[0][1])
    while data_strace[trace_cur_index][1] < pid_related_pkt[0][1]:
        trace_cur_index = trace_cur_index + 1
        if trace_cur_index >= strace_length:
            trace_cur_index = trace_cur_index - 1
            break
    # print(data_strace[trace_cur_index][0])
    last_flag = 0
    # if (pid_related_pkt[1][1]-pid_related_pkt[0][1]) < t_w:
    #     last_flag = 1
    # else:
    #     last_flag = 0
    i = 1
    session_times = []
    data_item_times = []
    while i < final_pkt_length:
        # print(pid_related_pkt[i][1])
        # print(i)
        if last_flag == 0:
            session_times.append(pid_related_pkt[i-1][1])
        temp_seg_len = pid_related_pkt[i][1]-pid_related_pkt[i-1][1]
        # print(temp_seg_len)
        # command features + 2 pkt features (len, ttl) + 2 trace features (return value, duration) + 11 battery + 8 cpu + 7 mem + 2 log + previous state + label
        temp_feature = [0]*np.shape(all_unique_command)[0]
        # print(np.shape(temp_feature))
        if temp_seg_len > t_s:
            data_item_times.append(pid_related_pkt[i - 1][1])
            # print(data_strace[trace_cur_index][1])
            session_times.append(pid_related_pkt[i-1][1])
            while data_strace[trace_cur_index][1] - pid_related_pkt[i-1][1] < t_w:
                # print(data_strace[trace_cur_index][2])
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                # print(command_index)
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
                # input()
            # print(temp_feature)
            if '0x' in str(data_strace[trace_cur_index-1][4]):
                data_strace[trace_cur_index-1][4] = int(data_strace[trace_cur_index-1][4],16)
            temp_feature.append(int(data_strace[trace_cur_index-1][4])) # ret
            temp_feature.append(data_strace[trace_cur_index-1][5]) # duration
            temp_feature.append(pid_related_pkt[i-1][8]) # pkt len
            temp_feature.append(pid_related_pkt[i-1][9]) # ttl
            # use timestamp to add other features: battery, cpu, logcat, memory
            # battery feature
            while data_battery[battery_index][1] < pid_related_pkt[i-1][1]+t_w:
                battery_index += 1
                if battery_index >= battery_length:
                    battery_index = battery_index - 1
                    break
            temp_battery_battery = data_battery[battery_index-1][2]-data_battery[battery_index-2][2]
            temp_battery_cpu = data_battery[battery_index-1][3]-data_battery[battery_index-2][3]
            temp_battery_radio = data_battery[battery_index-1][4]-data_battery[battery_index-2][4]
            temp_battery_sensor = data_battery[battery_index-1][5]-data_battery[battery_index-2][5]
            temp_battery_wake = data_battery[battery_index-1][6]-data_battery[battery_index-2][6]
            temp_battery_include = data_battery[battery_index-1][7]-data_battery[battery_index-2][7]
            temp_battery_proportional = data_battery[battery_index-1][8]-data_battery[battery_index-2][8]
            temp_battery_screen = data_battery[battery_index-1][9]-data_battery[battery_index-2][9]
            temp_battery_ms_per_pkt = data_battery[battery_index-1][10]
            temp_battery_num_pkt = data_battery[battery_index-1][11]-data_battery[battery_index-2][11]
            temp_battery_t_trans = data_battery[battery_index-1][12]-data_battery[battery_index-2][12]
            temp_feature.append(temp_battery_battery)
            temp_feature.append(temp_battery_cpu)
            temp_feature.append(temp_battery_radio)
            temp_feature.append(temp_battery_sensor)
            temp_feature.append(temp_battery_wake)
            temp_feature.append(temp_battery_include)
            temp_feature.append(temp_battery_proportional)
            temp_feature.append(temp_battery_screen)
            temp_feature.append(temp_battery_ms_per_pkt)
            temp_feature.append(temp_battery_num_pkt)
            temp_feature.append(temp_battery_t_trans)
            # cpu feature
            while data_cpu[cpu_index][1] < pid_related_pkt[i-1][1]+t_w:
                cpu_index += 1
                if cpu_index >= cpu_length:
                    cpu_index = cpu_index - 1
                    break
            temp_cpu_prio = data_cpu[cpu_index-1][2]
            temp_cpu_nice = data_cpu[cpu_index-1][3]
            temp_cpu_virt = data_cpu[cpu_index-1][4]
            temp_cpu_res = data_cpu[cpu_index-1][5]
            temp_cpu_shr = data_cpu[cpu_index-1][6]
            temp_cpu_state = data_cpu[cpu_index-1][7]
            temp_cpu_cpu = data_cpu[cpu_index-1][8]
            temp_cpu_mem = data_cpu[cpu_index-1][9]
            temp_feature.append(temp_cpu_prio)
            temp_feature.append(temp_cpu_nice)
            temp_feature.append(temp_cpu_virt)
            temp_feature.append(temp_cpu_res)
            temp_feature.append(temp_cpu_shr)
            temp_feature.append(temp_cpu_state)
            temp_feature.append(temp_cpu_cpu)
            temp_feature.append(temp_cpu_mem)
            # memory feature
            while data_memory[memory_index][1] < pid_related_pkt[i-1][1]+t_w:
                memory_index += 1
                if memory_index >= memory_length:
                    memory_index = memory_index - 1
                    break
            temp_mem_pss_total = data_memory[memory_index-1][2]
            temp_mem_pri_dirty = data_memory[memory_index-1][3]
            temp_mem_pri_clean = data_memory[memory_index-1][4]
            temp_mem_swap_dirty = data_memory[memory_index-1][5]
            temp_mem_heap_size = data_memory[memory_index-1][6]
            temp_mem_heap_alloc = data_memory[memory_index-1][7]
            temp_mem_heap_free = data_memory[memory_index-1][8]
            temp_feature.append(temp_mem_pss_total)
            temp_feature.append(temp_mem_pri_dirty)
            temp_feature.append(temp_mem_pri_clean)
            temp_feature.append(temp_mem_swap_dirty)
            temp_feature.append(temp_mem_heap_size)
            temp_feature.append(temp_mem_heap_alloc)
            temp_feature.append(temp_mem_heap_free)
            # logcat feature
            num_of_logs = 0
            while data_logcat[logcat_index][1] < pid_related_pkt[i-1][1]+t_w:
                num_of_logs += 1
                logcat_index += 1
                if logcat_index >= logcat_length:
                    logcat_index = logcat_index - 1
                    break
            temp_log_level = data_logcat[logcat_index - 1][4]
            temp_log_num = num_of_logs
            temp_feature.append(temp_log_level)
            temp_feature.append(temp_log_num)

            temp_feature.append(last_flag)
            temp_feature.append(0)
            last_flag = 0
            # print(temp_feature)
            # input()

            data_item.append(temp_feature)
            all_data_item.append(temp_feature)

            # for prediction
            temp_feature.append(temp_seg_len-t_w)
            eos_data_item.append(temp_feature)

            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        elif temp_seg_len > t_w and temp_seg_len <= t_s:
            # print(data_strace[trace_cur_index][1])
            data_item_times.append(pid_related_pkt[i - 1][1])
            while data_strace[trace_cur_index][1] - pid_related_pkt[i - 1][1] < t_w:
                # print(data_strace[trace_cur_index][2])
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                # print(command_index)
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
                # input()
            if '0x' in str(data_strace[trace_cur_index - 1][4]):
                data_strace[trace_cur_index - 1][4] = int(data_strace[trace_cur_index - 1][4], 16)
            temp_feature.append(int(data_strace[trace_cur_index - 1][4]))  # ret
            temp_feature.append(data_strace[trace_cur_index - 1][5])  # duration
            temp_feature.append(pid_related_pkt[i - 1][8])  # pkt len
            temp_feature.append(pid_related_pkt[i - 1][9])  # ttl
            # use timestamp to add other features: battery, cpu, logcat, memory
            # battery feature
            while data_battery[battery_index][1] < pid_related_pkt[i-1][1]+t_w:
                battery_index += 1
                if battery_index >= battery_length:
                    battery_index = battery_index - 1
                    break
            temp_battery_battery = data_battery[battery_index - 1][2] - data_battery[battery_index - 2][2]
            temp_battery_cpu = data_battery[battery_index - 1][3] - data_battery[battery_index - 2][3]
            temp_battery_radio = data_battery[battery_index - 1][4] - data_battery[battery_index - 2][4]
            temp_battery_sensor = data_battery[battery_index - 1][5] - data_battery[battery_index - 2][5]
            temp_battery_wake = data_battery[battery_index - 1][6] - data_battery[battery_index - 2][6]
            temp_battery_include = data_battery[battery_index - 1][7] - data_battery[battery_index - 2][7]
            temp_battery_proportional = data_battery[battery_index - 1][8] - data_battery[battery_index - 2][8]
            temp_battery_screen = data_battery[battery_index - 1][9] - data_battery[battery_index - 2][9]
            temp_battery_ms_per_pkt = data_battery[battery_index - 1][10]
            temp_battery_num_pkt = data_battery[battery_index - 1][11] - data_battery[battery_index - 2][11]
            temp_battery_t_trans = data_battery[battery_index - 1][12] - data_battery[battery_index - 2][12]
            temp_feature.append(temp_battery_battery)
            temp_feature.append(temp_battery_cpu)
            temp_feature.append(temp_battery_radio)
            temp_feature.append(temp_battery_sensor)
            temp_feature.append(temp_battery_wake)
            temp_feature.append(temp_battery_include)
            temp_feature.append(temp_battery_proportional)
            temp_feature.append(temp_battery_screen)
            temp_feature.append(temp_battery_ms_per_pkt)
            temp_feature.append(temp_battery_num_pkt)
            temp_feature.append(temp_battery_t_trans)
            # cpu feature
            while data_cpu[cpu_index][1] < pid_related_pkt[i-1][1]+t_w:
                cpu_index += 1
                if cpu_index >= cpu_length:
                    cpu_index = cpu_index - 1
                    break
            temp_cpu_prio = data_cpu[cpu_index - 1][2]
            temp_cpu_nice = data_cpu[cpu_index - 1][3]
            temp_cpu_virt = data_cpu[cpu_index - 1][4]
            temp_cpu_res = data_cpu[cpu_index - 1][5]
            temp_cpu_shr = data_cpu[cpu_index - 1][6]
            temp_cpu_state = data_cpu[cpu_index - 1][7]
            temp_cpu_cpu = data_cpu[cpu_index - 1][8]
            temp_cpu_mem = data_cpu[cpu_index - 1][9]
            temp_feature.append(temp_cpu_prio)
            temp_feature.append(temp_cpu_nice)
            temp_feature.append(temp_cpu_virt)
            temp_feature.append(temp_cpu_res)
            temp_feature.append(temp_cpu_shr)
            temp_feature.append(temp_cpu_state)
            temp_feature.append(temp_cpu_cpu)
            temp_feature.append(temp_cpu_mem)
            # memory feature
            while data_memory[memory_index][1] < pid_related_pkt[i-1][1]+t_w:
                memory_index += 1
                if memory_index >= memory_length:
                    memory_index = memory_index - 1
                    break
            temp_mem_pss_total = data_memory[memory_index - 1][2]
            temp_mem_pri_dirty = data_memory[memory_index - 1][3]
            temp_mem_pri_clean = data_memory[memory_index - 1][4]
            temp_mem_swap_dirty = data_memory[memory_index - 1][5]
            temp_mem_heap_size = data_memory[memory_index - 1][6]
            temp_mem_heap_alloc = data_memory[memory_index - 1][7]
            temp_mem_heap_free = data_memory[memory_index - 1][8]
            temp_feature.append(temp_mem_pss_total)
            temp_feature.append(temp_mem_pri_dirty)
            temp_feature.append(temp_mem_pri_clean)
            temp_feature.append(temp_mem_swap_dirty)
            temp_feature.append(temp_mem_heap_size)
            temp_feature.append(temp_mem_heap_alloc)
            temp_feature.append(temp_mem_heap_free)
            # logcat feature
            num_of_logs = 0
            while data_logcat[logcat_index][1] < pid_related_pkt[i-1][1]+t_w:
                num_of_logs += 1
                logcat_index += 1
                if logcat_index >= logcat_length:
                    logcat_index = logcat_index - 1
                    break
            temp_log_level = data_logcat[logcat_index - 1][4]
            temp_log_num = num_of_logs
            temp_feature.append(temp_log_level)
            temp_feature.append(temp_log_num)

            temp_feature.append(last_flag)
            temp_feature.append(1)
            last_flag = 1
            # print(temp_feature)
            # input()

            data_item.append(temp_feature)
            all_data_item.append(temp_feature)
            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        elif temp_seg_len <= t_w:
            start_time = pid_related_pkt[i-1][1]
            end_time = pid_related_pkt[i][1]
            # while (pid_related_pkt[i][1]-pid_related_pkt[i-1][1]) <= t_s:
            #     end_time = pid_related_pkt[i][1]

            if i+1 >= final_pkt_length:
                break
            else:
                while (pid_related_pkt[i+1][1]-pid_related_pkt[i][1]) <= t_s:
                    end_time = pid_related_pkt[i+1][1]
                    i = i+1
                    if i+1 >= final_pkt_length or (end_time-start_time) > t_w:
                        break
                # print("i:",i)
            if i+1>=final_pkt_length:
                break
            if pid_related_pkt[i + 1][1] - pid_related_pkt[i][1] > t_s:
                while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                    trace_cur_index = trace_cur_index + 1
                    if trace_cur_index >= strace_length:
                        trace_cur_index = trace_cur_index - 1
                        break
                i = i + 1
                continue
            data_item_times.append(start_time)
            # according to start_time and start_time+t_w to get feature and update trace_cur_index
            while data_strace[trace_cur_index][1] < (start_time+t_w) and data_strace[trace_cur_index][1] <= end_time:
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
            if '0x' in str(data_strace[trace_cur_index - 1][4]):
                data_strace[trace_cur_index - 1][4] = int(data_strace[trace_cur_index - 1][4], 16)
            temp_feature.append(int(data_strace[trace_cur_index - 1][4]))  # ret
            temp_feature.append(data_strace[trace_cur_index - 1][5])  # duration
            temp_feature.append(pid_related_pkt[i - 1][8])  # pkt len
            temp_feature.append(pid_related_pkt[i - 1][9])  # ttl
            # use timestamp to add other features: battery, cpu, logcat, memory
            # battery feature
            while data_battery[battery_index][1] < start_time+t_w:
                battery_index += 1
                if battery_index >= battery_length:
                    battery_index = battery_index - 1
                    break
            temp_battery_battery = data_battery[battery_index - 1][2] - data_battery[battery_index - 2][2]
            temp_battery_cpu = data_battery[battery_index - 1][3] - data_battery[battery_index - 2][3]
            temp_battery_radio = data_battery[battery_index - 1][4] - data_battery[battery_index - 2][4]
            temp_battery_sensor = data_battery[battery_index - 1][5] - data_battery[battery_index - 2][5]
            temp_battery_wake = data_battery[battery_index - 1][6] - data_battery[battery_index - 2][6]
            temp_battery_include = data_battery[battery_index - 1][7] - data_battery[battery_index - 2][7]
            temp_battery_proportional = data_battery[battery_index - 1][8] - data_battery[battery_index - 2][8]
            temp_battery_screen = data_battery[battery_index - 1][9] - data_battery[battery_index - 2][9]
            temp_battery_ms_per_pkt = data_battery[battery_index - 1][10]
            temp_battery_num_pkt = data_battery[battery_index - 1][11] - data_battery[battery_index - 2][11]
            temp_battery_t_trans = data_battery[battery_index - 1][12] - data_battery[battery_index - 2][12]
            temp_feature.append(temp_battery_battery)
            temp_feature.append(temp_battery_cpu)
            temp_feature.append(temp_battery_radio)
            temp_feature.append(temp_battery_sensor)
            temp_feature.append(temp_battery_wake)
            temp_feature.append(temp_battery_include)
            temp_feature.append(temp_battery_proportional)
            temp_feature.append(temp_battery_screen)
            temp_feature.append(temp_battery_ms_per_pkt)
            temp_feature.append(temp_battery_num_pkt)
            temp_feature.append(temp_battery_t_trans)
            # cpu feature
            while data_cpu[cpu_index][1] < start_time+t_w:
                cpu_index += 1
                if cpu_index >= cpu_length:
                    cpu_index = cpu_index - 1
                    break
            temp_cpu_prio = data_cpu[cpu_index - 1][2]
            temp_cpu_nice = data_cpu[cpu_index - 1][3]
            temp_cpu_virt = data_cpu[cpu_index - 1][4]
            temp_cpu_res = data_cpu[cpu_index - 1][5]
            temp_cpu_shr = data_cpu[cpu_index - 1][6]
            temp_cpu_state = data_cpu[cpu_index - 1][7]
            temp_cpu_cpu = data_cpu[cpu_index - 1][8]
            temp_cpu_mem = data_cpu[cpu_index - 1][9]
            temp_feature.append(temp_cpu_prio)
            temp_feature.append(temp_cpu_nice)
            temp_feature.append(temp_cpu_virt)
            temp_feature.append(temp_cpu_res)
            temp_feature.append(temp_cpu_shr)
            temp_feature.append(temp_cpu_state)
            temp_feature.append(temp_cpu_cpu)
            temp_feature.append(temp_cpu_mem)
            # memory feature
            while data_memory[memory_index][1] < start_time+t_w:
                memory_index += 1
                if memory_index >= memory_length:
                    memory_index = memory_index - 1
                    break
            temp_mem_pss_total = data_memory[memory_index - 1][2]
            temp_mem_pri_dirty = data_memory[memory_index - 1][3]
            temp_mem_pri_clean = data_memory[memory_index - 1][4]
            temp_mem_swap_dirty = data_memory[memory_index - 1][5]
            temp_mem_heap_size = data_memory[memory_index - 1][6]
            temp_mem_heap_alloc = data_memory[memory_index - 1][7]
            temp_mem_heap_free = data_memory[memory_index - 1][8]
            temp_feature.append(temp_mem_pss_total)
            temp_feature.append(temp_mem_pri_dirty)
            temp_feature.append(temp_mem_pri_clean)
            temp_feature.append(temp_mem_swap_dirty)
            temp_feature.append(temp_mem_heap_size)
            temp_feature.append(temp_mem_heap_alloc)
            temp_feature.append(temp_mem_heap_free)
            # logcat feature
            num_of_logs = 0
            if(logcat_index==logcat_length):
                logcat_index = logcat_index-1
            while data_logcat[logcat_index][1] < start_time+t_w:
                num_of_logs += 1
                logcat_index += 1
                if logcat_index >= logcat_length:
                    logcat_index = logcat_index - 1
                    break
            temp_log_level = data_logcat[logcat_index - 1][4]
            temp_log_num = num_of_logs
            temp_feature.append(temp_log_level)
            temp_feature.append(temp_log_num)

            temp_feature.append(last_flag)
            temp_feature.append(1)
            last_flag = 1
            # print(temp_feature)
            # input()

            data_item.append(temp_feature)
            all_data_item.append(temp_feature)
            if i == final_pkt_length:
                break;
            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        # print("trace_cur_index:", trace_cur_index)
        # print("i:", i)
        i = i + 1
    # print("features:",data_item)
    # print(np.shape(data_item))
    dataframe = pd.DataFrame(data_item)
    dataframe.to_csv(store_path + 'features_'+trace_num+'_all_feature_'+str(t_w)+'.csv')
    print(session_times)
    for session_i in range(1,len(session_times)):
        if session_i%2==0:
            inter_session_time.append(session_times[session_i]-session_times[session_i-1])
        else:
            intra_session_time.append(session_times[session_i]-session_times[session_i-1])
    file_command = open(store_path+'session_times.txt','w')
    file_command.write(str(session_times))

    for item_i in range(1,len(data_item_times)):
        inter_item_time.append(data_item_times[item_i]-data_item_times[item_i-1]-t_w)

    file_command = open(store_path+'data_item_times.txt','w')
    file_command.write(str(data_item_times))

    # input()

file_command = open(features_final_path+'inter_session_times.txt','w')
file_command.write(str(inter_session_time))
file_command = open(features_final_path+'intra_session_times.txt','w')
file_command.write(str(intra_session_time))

file_command = open(features_final_path+'inter_item_times.txt','w')
file_command.write(str(inter_item_time))

print("all_data_item:",all_data_item)
print(np.shape(all_data_item))
all_dataframe = pd.DataFrame(all_data_item)
all_dataframe.to_csv(features_final_path+'final_features_all_feature_'+str(t_w)+'.csv')

print("eos_data_item:",eos_data_item)
print(np.shape(eos_data_item))
eos_dataframe = pd.DataFrame(eos_data_item)
eos_dataframe.to_csv(features_final_path+'final_features_all_feature_for_prediction_'+str(t_w)+'.csv')