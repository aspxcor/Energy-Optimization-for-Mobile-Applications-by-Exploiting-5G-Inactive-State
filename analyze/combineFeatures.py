from scapy.all import *
import json
import numpy as np
import datetime
import pandas as pd
import math
from collections import Counter
import os

features_final_path = 'E:\\Emnets\\5G\\powerMonitor\\ZTE\data\\'
feature_dirs = []
trace_nums = []
all_unique_command = []
for file in os.listdir(features_final_path):
    print(file)
    file_path = os.path.join(features_final_path,file)
    if os.path.isdir(file_path) and ("trace" in file):
        feature_dirs.append(file_path)
        temp_pos = file.rindex('e')
        trace_nums.append(file[temp_pos+1:])
print(trace_nums)

for trace_num in trace_nums:
    # trace_num = '10'
    port_num = '18026'
    store_path = 'E:\\Emnets\\5G\\powerMonitor\\ZTE\data\\trace'+ trace_num+ '\\'
    file_path_strace = store_path+'trace_'+trace_num+'.csv'
    file_path_pcap = store_path + 'pcap_'+trace_num+'.csv'
    file_path_pidport = store_path + 'port_PID'+ port_num +'_'+trace_num+'.csv'


    df_strace = pd.read_csv(file_path_strace)
    df_pcap = pd.read_csv(file_path_pcap)
    df_pidport = pd.read_csv(file_path_pidport)

    print("输出strace列标题",df_strace.columns.values)
    print("输出pcap列标题",df_pcap.columns.values)
    print("输出pid_port列标题",df_pidport.columns.values)

    data_strace = df_strace.loc[:,:].values
    data_pcap = df_pcap.loc[:,:].values
    data_pidport = df_pidport.loc[:,:].values
    print(data_pidport)
    print(np.shape(data_pidport))

    pid_related_pkt = []
    pkt_length = len(data_pcap)
    port_length = len(data_pidport)
    cur_search_index = 0
    # for index in range(pkt_length):
    #     pkt_time[index] = 3600*data_pcap[index][1]+60*data_pcap[index][2]+data_pcap[index][3]+data_pcap[index][4]/1000000.0
    # for index_port in range(port_length):
    #     port_time[index_port] = 3600*data_pidport[index_port][1]+60*data_pidport[index_port][2]+data_pidport[index_port][3]+data_pidport[index_port][4]/1000000000.0

    each_port_len = len(data_pidport[0])
    for index in range(pkt_length):
        while data_pidport[cur_search_index][1] < data_pcap[index][1]:
            cur_search_index = cur_search_index + 1
        # print(cur_search_index)
        # print(index)
        # input()
        cur_search_index = cur_search_index - 1
        start_port = 6
        temp_port = []
        for i in range(start_port,each_port_len):
            if np.isnan(data_pidport[cur_search_index][i]):
                break
            else:
                temp_port.append(data_pidport[cur_search_index][i])
        for i in range(start_port,each_port_len):
            if np.isnan(data_pidport[cur_search_index+1][i]):
                break
            else:
                temp_port.append(data_pidport[cur_search_index+1][i])
            # print(index)
            # print(temp_port)
        # print(cur_search_index)
        # print(index)
        # print(temp_port)
        # input()
        if (data_pcap[index][6] in temp_port) or (data_pcap[index][7] in temp_port):
            pid_related_pkt.append(data_pcap[index])

    # print(pid_related_pkt)
    print(np.shape(pid_related_pkt))
    # input()
    dataframe = pd.DataFrame(pid_related_pkt)
    # print(dataframe)
    path = store_path + 'pcap_'+trace_num+'_final.csv'
    if not os.path.exists(path):
        dataframe.to_csv(store_path + 'pcap_'+trace_num+'_final.csv')
    # dataframe.to_csv(store_path + 'pcap_' + trace_num + '_final.csv')

    strace_length = len(data_strace)
    unique_command = []
    for i in range(strace_length):
        if data_strace[i][2] not in unique_command:
            unique_command.append(data_strace[i][2])
        if data_strace[i][2] not in all_unique_command:
            all_unique_command.append(data_strace[i][2])
    print(unique_command)
    print("unique command:", np.shape(unique_command))


print(all_unique_command)
print("all unique command:",np.shape(all_unique_command))
# input()

all_data_item = []

for trace_num in trace_nums:
    # trace_num = '10'
    port_num = '18026'
    store_path = 'E:\\Emnets\\5G\\powerMonitor\\ZTE\data\\trace' + trace_num + '\\'
    file_path_strace = store_path + 'trace_' + trace_num + '.csv'
    file_path_pcap = store_path + 'pcap_' + trace_num + '.csv'
    file_path_pidport = store_path + 'port_PID' + port_num + '_' + trace_num + '.csv'
    file_path_related_pkt = store_path+'pcap_'+trace_num+'_final.csv'

    df_strace = pd.read_csv(file_path_strace)
    df_pcap = pd.read_csv(file_path_pcap)
    df_pidport = pd.read_csv(file_path_pidport)
    df_related_pkt = pd.read_csv(file_path_related_pkt)

    print("输出strace列标题", df_strace.columns.values)
    print("输出pcap列标题", df_pcap.columns.values)
    print("输出pid_port列标题", df_pidport.columns.values)
    print("输出related_pkt列标题", df_related_pkt.columns.values)

    data_strace = df_strace.loc[:, :].values
    data_pcap = df_pcap.loc[:, :].values
    data_pidport = df_pidport.loc[:, :].values
    data_related_pkt = df_related_pkt.loc[:, :].values
    strace_length = len(data_strace)
    pkt_length = len(data_pcap)
    port_length = len(data_pidport)
    temp_len = np.shape(data_related_pkt)[0]
    col = np.shape(data_related_pkt)[1]
    pid_related_pkt = []
    for temp_i in range(temp_len):
        pid_related_pkt.append(data_related_pkt[temp_i, 1:col])

    # pid_related_pkt = data_related_pkt[:, 1:col]
    # print(pid_related_pkt)
    # print(np.shape(pid_related_pkt))
    # input()
    pid_related_pkt.sort(key=lambda x: x[1], reverse=False)
    # print(pid_related_pkt)
    t_s = 2
    t_w = 0.4

    final_pkt_length = len(pid_related_pkt)
    data_item = []
    trace_cur_index = 0
    while data_strace[trace_cur_index][1] < pid_related_pkt[0][1]:
        trace_cur_index = trace_cur_index + 1
    # print(data_strace[trace_cur_index][0])
    last_flag = 0
    i = 1
    while i < final_pkt_length:
        # print(pid_related_pkt[i][1])
        temp_seg_len = pid_related_pkt[i][1]-pid_related_pkt[i-1][1]
        # print(temp_seg_len)
        # command features + previous state + flag
        temp_feature = np.zeros(np.shape(all_unique_command)[0]+1+1)
        # print(np.shape(temp_feature))
        if temp_seg_len > t_s:
            temp_feature[-1] = 0
            temp_feature[-2] = last_flag
            last_flag = 0
            # print(data_strace[trace_cur_index][1])
            while data_strace[trace_cur_index][1] - pid_related_pkt[i-1][1] < t_w:
                # print(data_strace[trace_cur_index][2])
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                # print(command_index)
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
                # input()
            data_item.append(temp_feature)
            all_data_item.append(temp_feature)
            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        elif temp_seg_len > t_w and temp_seg_len <= t_s:
            temp_feature[-1] = 1
            temp_feature[-2] = last_flag
            last_flag = 1
            # print(data_strace[trace_cur_index][1])
            while data_strace[trace_cur_index][1] - pid_related_pkt[i - 1][1] < t_w:
                # print(data_strace[trace_cur_index][2])
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                # print(command_index)
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
                # input()
            data_item.append(temp_feature)
            all_data_item.append(temp_feature)
            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        elif temp_seg_len <= t_w:
            start_time = pid_related_pkt[i-1][1]
            end_time = pid_related_pkt[i][1]
            if i+1 >= final_pkt_length:
                end_time = pid_related_pkt[i][1]
            else:
                while (pid_related_pkt[i+1][1]-pid_related_pkt[i][1]) <= t_s:
                    end_time = pid_related_pkt[i+1][1]
                    i = i+1
                    if i+1 >= final_pkt_length or (end_time-start_time) > t_w:
                        break
                # print("i:",i)
            # according to start_time and start_time+t_w to get feature and update trace_cur_index
            temp_feature[-1] = 1
            temp_feature[-2] = last_flag
            last_flag = 1
            while data_strace[trace_cur_index][1] < (start_time+t_w) and data_strace[trace_cur_index][1] <= end_time:
                command_index = all_unique_command.index(data_strace[trace_cur_index][2])
                temp_feature[command_index] = 1
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
            data_item.append(temp_feature)
            all_data_item.append(temp_feature)
            while data_strace[trace_cur_index][1] < pid_related_pkt[i][1]:
                trace_cur_index = trace_cur_index + 1
                if trace_cur_index >= strace_length:
                    trace_cur_index = trace_cur_index - 1
                    break
        # print("trace_cur_index:", trace_cur_index)
        # print("i:", i)
        i = i + 1
    print("features:",data_item)
    print(np.shape(data_item))
    dataframe = pd.DataFrame(data_item)
    dataframe.to_csv(store_path + 'features_'+trace_num+'.csv')

print("all_data_item:",all_data_item)
print(np.shape(all_data_item))
all_dataframe = pd.DataFrame(all_data_item)
all_dataframe.to_csv(features_final_path+'final_features.csv')
